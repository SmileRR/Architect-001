# 架构师训练营 第1期

## 01. 架构方法

### 4+1视图模型

- 逻辑视图（Logical View）
- 过程视图（Process View）
- 物理视图（Physical View)
- 开发视图（Development View）
- 场景视图（Scenarios）

### 建模语言-UML

- 什么是模型？

	- 领域问题
	- 概念模型
	- 系统需求
	- 解决方案

- 静态图

	- 用例图（UseCase Diagram)
	- 对象图（Object Diagram）
	- 类图（Class Diagram）
	- 组件图（Component Diagram）
	- 包图（Package Diagram）
	- 部署图（Deployment Diagram）

- 动态图

	- 协作图（Collaboration Diagram）
	- 序列图（Sequence Diagram）
	- 活动图（Activity Diagram）
	- 状态图（State Diagram）

- 工具

	- Viso
	- processon
	- drawio

## 02. 框架设计

### 形形色色的编程语言

- 底层： 汇编语言
- 结构化的Basic， C
- 脚本语言Perl
- 面向对象C++, Java

### 编程语言的本质

- 问题领域

	- 领域问题
	- 模型
	- 软件系统

- 抽象的种类

	- 对基础及其进行抽象：机器代码、汇编语言
	- 对计算处理逻辑抽象：非结构化高级语言（Basic，Fortran）
	- 问题领域的抽象

		- 结构化程序设计
		- 面向对象程序设计

### 面向对象三要素

- 封装性(Encapsulation)

	- 隐藏接口实现（访问控制）
	- 定义接口

- 继承性(Inheritance)

	- IS-A（继承）
	- HAS-A(组合）

- 多态性(Polymorphism)

	- 后期绑定（虚函数）
	- 向上转型（Up Casing）

### 面向对象分析与设计

- OOA

	- 充血模型 vs 贫血模型
	- 领域驱动设计DDD

- OOD

	- 目的：强内聚、低耦合

		- 易扩展
		- 更强壮
		- 可移植
		- 更简单

	- 指导原则（独立于编程语言）
	- OOD设计原则（SOLID)

		- 开闭原则（OCP)

			- 对扩展开放，对更改关闭。
			- 不需要修改软件实体就能实现功能的扩展
			- 关键：抽象

		- 依赖倒置原则（DIP)

			- 高层模块不依赖于低层模块；大家都依赖于抽象
			- 抽象不能依赖于实现，而实现依赖于抽象

		- Liskov替换原则（LSP)

			- 子类必须能替换掉它的基类型

		- 单一职责原则（SRP)

			- 一个类只能有一个引起它变化的原因
			- 用于： 设计一个类

		- 接口分离原则(ISP)

			- 不应强迫客户程序依赖它不需要的方法
			- 用于：设计一个接口

	- 框架（Frameworks） vs 工具

	  是对莫一类架构方案的可复用的设计与实现

		- 框架调用程序代码，应用程序调用工具
		- 用框架保证架构落地，用工具提高开发效率

### 案例：反应式编程框架Flower（Based on Akka)

## 03. 代码重构

### 设计模式（DesignPatterns：GOF）

- 设计模式的4个组成部分

	- 名称
	- 待解问题
	- 解决方案
	- 结论（利和弊）,主要是对系统弹性、扩展性、可移植行的影响

- 创建模式

	- 工厂方法（FactoryMethod）
	- 抽象工厂（AbstractFactory)
	- 生成器(Builder)
	- 原型（Prototype）
	- 单例（Singleton）

- 结构模式

	- 适配器（Adapter）

		- JDBC Driver

	- 桥接（Bridge）
	- 组合（Composite）

		- AWT控件

	- 装饰器（Decorator）

		- Java Servlet Request，Response Wrapper
		- Collections..sychronizedList(list)
		- Java I/O类库

	- 外观（Facade）
	- 享元（Flyweight）
	- 代理（Proxy）

- 行为模式

	- 职责链（Chain of Responsibility）
	- 命令（Command）
	- 迭代器（Iterator）
	- 中介（Mediator)
	- 备忘录（Memoto）
	- 观察者（Observer）
	- 状态（State）
	- 策略（Strategy）
	- 模板方法（Template）

		- Junit
		- Java Servlet

	- 访问者（Visitor）

### Spring中的设计模式

- 依赖注入（DI)
- 控制反转（IoC)
- 单例模式（Singleton）: Bean
- Spring MVC

## 04. 系统架构

### 互联网系统面临的挑战

- 高并发、大流量
- 高可用
- 海量数据
- 用户分布广泛、网络情况复杂
- 安全环境恶劣
- 需求快速变更、发布频繁
- 渐进式发展

### 应对高并发（技术方向）

- 垂直伸缩（升级硬件、网络吞吐能力）

	- 使用RAID（独立冗余磁盘阵列）磁盘增减I/O吞吐能力
	- 更换SSD（固态硬盘）提升I/O
	- 增加内存减少I/O
	- 升级网络接口（网卡）提高网络吞吐能力， RDMA
	- 多核CPU,超线程, NUMA

- 水平伸缩

### 架构演化

- 0.单机应用
- 1.应用数据分离
- 2.使用缓存改善性能
- 3.服务其集权改善并发处理能力
- 4.数据库读写分离
- 5.反向代理，CDN加速网站响应
- 6.使用分布式文件系统，分布式数据库（分库、分表）
- 7.使用NoSQL 和搜索引擎
- 8.业务拆分
- 9.微服务及中台化
- 10.大数据与智能化

### 架构模式

- 分层（横向拆分）
- 分割（垂直拆分）
- 分布式

	- 分布式应用和服务
	- 分布式静态资源
	- 分布式数据和存储
	- 分布式计算

- 集群
- 缓存

	- CDN
	- 反向代理
	- 本地缓存
	- 远程缓存

- 异步(消息中间件）

	- 提高系统可用性
	- 加快网站响应
	- 消除并发访问高峰

- 冗余
- 自动化
- 安全

### 架构设计核心要素（衡量指标）

- 高性能
- 高可用
- 可伸缩
- 可扩展
- 安全

### 互联网架构技术一览

- 前端架构

	- App及Web开发技术
	- 浏览器及HTTP优化技术
	- CDN
	- 动静分离
	- 图片服务
	- 反向代理
	- DNS

- 网关及应用层架构

	- 网关架构
	- 负载均衡
	- 动态页面静态化
	- 业务拆分

- 服务层架构

	- 微服务框架
	- 分布式消息队列
	- 分布式缓存
	- 分布式一致性（锁）服务-事务

- 存储层架构

	- 分布式文件
	- 分布式关系数据库
	- NoSQL数据库

- 后台架构

	- 大数据平台
	- 搜索引擎
	- 推荐引擎
	- 数据仓库

- 运维与安全

	- 数据采集与展示
	- 数据监控与报警
	- 攻击与防护
	- 数据加密与解密

## 05. 技术选型

### 分布式缓存架构

- 缓存（Cache）vs 缓冲（Buffer）
- 特点

	- 技术简单
	- 性能提升显著

- 缓存类型

	- CPU L1/L2 Cache
	- 操作系统缓存
	- 数据库缓存
	- JVM编译缓存
	- CDN缓存
	- 代理与反向代理缓存
	- 前端缓存
	- 应用程序缓存
	- 分布式对象缓存

- 缓存数据存储(Hash表）
- 缓存的关键指标（命中率）

	- 缓存键集合大小
	- 缓存空间
	- 缓存寿命

- 分布式缓存

	- 分布式缓存架构
	- 分布式缓存模型
	- 一致性hash算法
	- Redis VS Memcached

- 缓存注意事项

	- 频繁修改的数据
	- 没有热点的访问
	- 数据不一致与脏读
	- 缓存雪崩
	- 缓存预热
	- 缓存穿透

### 消息队列与异步架构

- 异步调用（vs 同步调用）

	- 有回调的异步调用
	- 多次异步调用
	- 不阻塞应用线程

- 消息队列

	- 组成

		- 消息生产者
		- 消息队列
		- 消息消费者

	- 类型

		- 点对点模型（P2P)
		- 发布订阅模型（Pub-Sub）

	- 优点

		- 异步处理提升处理性能
		- 更好的伸缩性
		- 削峰填谷
		- 失败隔离和自我修复
		- 解耦

	- 事件驱动架构（EDA)
	- 常用协议

		- STOMP(Streaming Text Orientated Message Protocol）流文本定向消息协议-TCP层
		- AMQP（Advanced Message Queuing Protocol），应用层协议
		- XMPP，基于XML
		- MQTT:物联网重要协议
		- JMS，比其他协议更高一层的抽象。JAVA规范

	- MQ 产品比较

		- RabbitMQ

			- Erlang

		- Active MQ

			- Apache，Java

		- Rocket MQ

			- Ali，Java

		- Kafka

			- LinkedIn，Scala&Java

### 负载均衡架构

- 类型

	- HTTP重定向
	- DNS负载均衡
	- 反向代理
	- IP（网关）负载均衡
	- 数据链路层（网关)负载均衡

- 算法

	- 轮询（Round Robin）
	- 加权轮询（Weighted Round Robin）
	- 随机（Random）
	- 最少连接（Least Connections）
	- 源地址散列（Source IP Hash）

- Session管理

	- Session 复制
	- Session绑定
	- 利用Cookie记录Session
	- Session服务器

### 分布式数据库

- MYSQL

	- 主从复制

		- 独写分离

	- 一主多从

		- 分摊负载
		- 专机专用
		- 便于冷备
		- 从节点高可用

	- 主主复制

		- 主节点高可用
		- 主主失效恢复
		- 注意事项

			- 两个主数据库不能并发写
			- 没有增加写并发能力
			- 更新表结构会导致巨大同步延迟

- 数据分片

	- 目标
	- 特点
	- 原理

		- 硬编码分片
		- 映射表外部存储

	- 挑战

		- 大量额外代码实现分片
		- 无法执行多分片联合查询
		- 无法使用数据库事务
		- 数据增长，如何增加服务器节点？

- 分布式数据库中间件

	- Cobar（阿里）

		- 前端通讯模块
		- SQL解析模块
		- SQL 路由模块
		- SQL执行代理模块
		- 后端通讯模块
		- 结果合并模块

	- TDDL(阿里）
	- MyCat
	- Oneproxy
	- Kingshard
	- Vitess（Youtube）
	- Atlas(360)
	- MaxScale(MariaDB)
	- MySQL Route
	- ShardingSphere

### NoSQL

- CAP原理

	- 一致性（Consistency）
	- 可用性（Availability）
	- 分区容错（Partition Tolerance）

- ACID(关系数据库）

	- 原子性（Atomic）
	- 一致性（Consistency）
	- 隔离性（Isolation）
	- 持久性（Durablility）

- BASE

	- 基本可用（Basically Available）

		- 系统出现不可预知故障时，允许部分可用性

	- 软状态（Soft State）

		- 允许系统中的数据出现中间状态

	- 最终一致性（Eventually Consistent）

		- 系统中的所有数据副本，经过一段时间同步后最终达到一个一致的状态

- 实现

	- Cassandra

		- 投票解决冲突

	- HBase （依赖Zookeeper）
	- LSM树（Log Structured Merge Tree）

### 分布式一致 - ZooKeeper

- 分布式系统脑裂
- 案例场景

	- 数据库主主备份

- 分布式一致算法（Paxos）

	- Proposer
	- Acceptor
	- Learner

- Zab协议（Zookeeper Atomic Broadcast）
- API

	- create
	- delete
	- setData
	- getData
	- exists
	- getChildren
	- sync
	- multi

- 配置管理

	- Administrator（SetData）
	- Consumer（getData）

- 负载均衡与失效转移

### 搜索引擎

- 网络爬虫

	- 爬虫禁爬协议（Robot.txt)

- 网页去重
- 存储与计算

	- 倒排索引

		- 内容相似性

	- 链接关系

		- 链接分析

	- 网页反作弊
	- 加权词频排序算法

		- TF=某个词在该文档中出现的次数/该文档总词数

	- 汉语处理组件包

- 网页排序
- Cache 系统
- 检索分析
- Elastic Search vs Luncene

	- Luncene 专注于搜索底层建设， Elastic Search专注于企业应用
	- Luncene是单节点API， Elastic Search是分布式的
	- Luncene需要二次开发，Elastic Search直接用

### 案例：Doris-海量KV Engine

- 当前现状
- 产品需求
- 产品目标
- 技术指标
- 逻辑架构

	- KV Storage 概念模型

- 关键技术点

	- 数据分区
	- 基于虚拟节点的分区算法
	- 集群管理-健康检查和配置抓取（Config Server）
	- 可用性关键场景

		- 瞬时失效
		- 临时失效
		- 永久失效

	- 扩容（实时数据迁移)

- 产品规划

	- Doris和平台产品关系
	- 产品规划（功能和版本）
	- 研发计划（功能需求）
	- 项目计划

		- DEV
		- QA

	- 实施计划

## 06. 性能优化

### 性能测试

- 视角

	- 主观：用户感受
	- 客观：性能指标

- 指标

	- 响应时间
	- 并发数
	- 吞吐量

		- TPS
		- QPS

	- 性能计数器

		- System Load
		- 对象与线程数
		- 内存使用
		- CPU使用
		- 磁盘与网络I/O

- 测试方法

	- 性能测试
	- 负载测试（Load Testing)
	- 压力测试(Stress Testing）

		- 尖峰测试（Spike Testing）

	- 可扩展性测试（Scalability Testing)
	- 容量测试（Volume Teting）
	- 持久测试（Endurance Testing）

- 全链路压测

	- 数据构造
	- 数据隔离

		- 逻辑隔离
		- 虚拟隔离
		- 物理隔离

	- 流量构造
	- 全链路压测平台化

### 性能优化方法论

- 一般方法

	- 性能测试，获得新能指标
	- 指标分析，发现性能与资源瓶颈
	- 架构与代码分析，寻找新能与资源瓶颈
	- 架构与代码优化，优化关键技术点
	- 性能测试，性能优化闭环

- 分层思想

	- 机房与骨干网络

		- 异地多活-多机房架构
		- 专线网络与自主CDN建设

	- 服务器与硬件

		- CPU，磁盘，内存，网卡

	- 操作系统
	- 虚拟机
	- 基础组件
	- 软件架构

		- 缓存
		- 异步
		- 集群

	- 软件代码

		- 并发编程，多线程与锁
		- 资源复用，线程池与对象池
		- 异步编程，生产者与消费者
		- 数据结构，数组、链表、hash表、树

### 操作系统

- 程序运行时架构

	- 磁盘（程序代码）
	- 内存-进程

		- 可执行代码
		- 堆内存空间
		- 栈内存空间
		- 进程数据结构

	- CPU

- 进程运行期状态

	- 运行
	- 就绪
	- 阻塞

- 进程VS线程

	- 进程是操作系统资源分配的基本单位；线程是任务调度和执行的基本单位
	- 一个进程可以有多个线程，操作系统中能同时运行多个进程
	- OS给进程分配内存，线程共享进程资源

- 线程概念

	- 线程栈
	- 线程安全
	- 临界区
	- 阻塞导致高并发系统崩溃

		- 避免

			- 限流
			- 降级
			- 反应式：异步，无临界区

### 锁

- 锁原语（CAS:V,E,N)

	- V:要更新的变量
	- E:预期值
	- N:新值

- 类型

	- 偏向锁

		- 一段同步代码一直被一个线程访问，该线程自动获取锁，降低获取锁代价

	- 轻量级锁

		- 锁是偏向锁时被另一个线程访问，偏向锁会升级为轻量锁，其他线程以自旋形式尝试获取锁，不会阻塞

	- 重量级锁

		- 轻量级锁，另一线程自旋一定次数后还没有获取到锁就会进入阻塞状态

	- 总线锁与缓存锁-多CPU情况下
	- 公平锁与非公平锁
	- 可重入锁
	- 独享锁/互斥锁 共享锁，读写锁
	- 乐观锁，悲观锁
	- 分段锁
	- 自旋锁

### 文件与硬盘I/O

- 磁盘

	- 机械硬盘
	- 固态硬盘SSD

- 存储结构

	- B+树
	- LSM树
	- 文件控制块（FCB)

		- Linux Inode

	- RAID 独立硬盘冗余阵列

		- RAID0
		- RAID1
		- RAID10
		- RAID5
		- RAID6

	- 分布式文件系统HDFS

		- Name Node

			- 元数据：文件名，副本数

		- Data Node

### 数据结构与算法

- 时间复杂度与空间复杂度
- 数据结构

	- 数组
	- 链表
	- Hash表
	- 树

		- 二叉排序树

			- 不平衡
			- 平衡

		- 红黑树

- 常用算法

	- 穷举算法
	- 递归算法
	- 贪心算法

		- 迪杰斯特拉算法（最快路径）

	- 动态规划
	- 遗传算法

### 网络通讯协议

- OSI七层模型

	- 应用层（Application）

		- HTTP 协议

			- 7种方法

				- Get，Head，Post，Put，Delete，Trace，Options

			- 5中状态

				- 1XX消息
				- 2XX成功
				- 3XX重定向
				- 4XX请求错误
				- 5XX服务器错误

		- 协议版本

			- HTTP/1.0（TCP)
			- HTTP/1.1(TCP)

				- 允许复用TCP连接，但任意时间点每个连接只能执行一次请求/响应交换

			- HTTP/2(TCP)

				- 一个TCP连接可以同时传输多个请求/响应
				- 队头堵塞现象

			- HTTP/3

	- 表示层（Presentation)
	- 会话层（Session）
	- 传输层（Transport）

		- UDP协议
		- TCP协议

			- 建立连接3次握手

				- SYN
				- SYN, ACK
				- ACK

			- 关闭连接4次握手

				- FIN
				- ACK
				- FIN
				- ACK

	- 网络层（Network）

		- IP协议

	- 数据链路层（DataLink）

		- 网卡MAC地址

	- 物理层（Physical）

		- 光信号，电信号，电磁信号

- TCP/IP四层

	- 应用层

		- HTTP协议头

	- 传输层

		- TCP协议头

	- 网络互联层

		- IP地址

	- 网络访问（链路）层

		- 网卡mac

### 非阻塞网络I/O（BIO vs NIO)

- 网络请求

	- Socket，端口，进程
	- 服务器 - 客户端
	- 多线程服务器 - 客户端
	- 线程池服务器

- 阻塞I/O : BIO 
- 非阻塞I/O： NIO

	- Java NIO
	- 编程模型

		- Socket
		- Channel
		- Selector

			- 系统I/O复用方式

				- select
				- poll
				- epoll

		- Buffer

### 数据库架构

- PrepareStatement预编译
- SQL执行过程

	- 连接器

		- 数据源：连接池

	- 语法分析器
	- 语义分析器与优化器
	- 执行引擎

- 索引

	- B+树
	- 聚簇索引：主键
	- 非聚簇索引

- 事务

	- 特性：ACID
	- 事务日志

### JVM虚拟机原理

### Java代码优化

### 案例：秒杀

## 07. 模块分解

### 微服务框架

### ServiceMesh服务网格

### 微服务架构实践

- CQRS
- EventSourcing

### 微服务网关

### 领域驱动设计DDD

### 组件设计原则

## 08. 安全稳定

### 安全架构

### 高可用系统的度量

### 高可用架构

### 高可用系统的运维

### 故障案例分析

## 09. 数据应用

### 大数据概述

### HDFS（文件存储）

### MapReduce（分布式计算）

### Yarn（调度）

### Hive

### HiveMetaStore

### Spark

- RDD

### 流计算

- Storm
- SparkStreaming
- Flink

### HiBench

### 大数据可视化

### 大数据算法与机器学习

## 10. 技术创新

### 大数据平台

- 大数据平台架构

	- 数据采集
	- 数据处理
	- 数据输出与展示

- 物联网平台
- 子主题 2

### 区块链

## 11. 技术管理

*XMind - Trial Version*